<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>GPS → ThingSpeak + Merge Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:1rem;background:#f6f7fb;color:#111}
    h1{margin:.2rem 0 1rem}
    #map{height:380px;border-radius:10px;margin:10px 0;background:#e9eef5}
    .row{display:flex;flex-wrap:wrap;gap:1rem}
    .col{flex:1 1 340px;background:#fff;border-radius:12px;box-shadow:0 8px 18px rgba(0,0,0,.08);padding:1rem}
    .btn{padding:.6rem 1rem;border:0;border-radius:8px;cursor:pointer;font-weight:600}
    .primary{background:#2563eb;color:#fff}
    .ghost{background:#e5e7eb}
    .ok{color:#16a34a}.warn{color:#f59e0b}.err{color:#ef4444}.muted{color:#6b7280}
    table{width:100%;border-collapse:collapse;font-size:.95rem}
    th,td{border:1px solid #e5e7eb;padding:.45rem .5rem}
    th{background:#f3f4f6;text-align:left}
    .controls label{display:block;font-size:.9rem;margin:.4rem 0 .2rem}
    .controls input{width:100%;padding:.45rem .5rem;border:1px solid #d1d5db;border-radius:8px}
  </style>
</head>
<body>

<h1>GPS → ThingSpeak (phone 4G) + Merged Table</h1>
<p>Status: <span id="status" class="muted">Idle</span></p>

<div class="row">
  <!-- LEFT: GPS uploader + map -->
  <div class="col">
    <button class="btn primary" id="startBtn">Start GPS Upload</button>
    <button class="btn ghost" id="stopBtn">Stop</button>
    <div id="map"></div>
    <p class="muted" style="margin:.2rem 0 0">Writes: field7 = Latitude, field8 = Longitude (once per 80-s slot)</p>
  </div>

  <!-- RIGHT: Merge viewer -->
  <div class="col">
    <h3 style="margin:.2rem 0 .6rem">Fetch & Merge from ThingSpeak (same channel)</h3>
    <div class="controls">
      <label>Channel ID</label>
      <input id="chId" value="2960675" />
      <label>Read API Key (leave blank if public)</label>
      <input id="readKey" value="" />
      <label>How many latest rows</label>
      <input id="results" type="number" value="120" />
      <label>Merge window (seconds)</label>
      <input id="window" type="number" value="90" />
    </div>
    <p style="margin:.6rem 0">
      <button class="btn primary" id="fetchBtn">Fetch & Merge</button>
      <button class="btn ghost" id="dlBtn" disabled>Download CSV</button>
    </p>
    <div id="mergeStatus" class="muted">Waiting…</div>
    <div style="max-height:340px;overflow:auto;margin-top:.5rem">
      <table id="tbl"></table>
    </div>
  </div>
</div>

<script>
/* ==== CONFIG (GPS writer) ==== */
const THINGSPEAK_WRITE_KEY = "9YXHS30JF6Z9YHXI";
const THINGSPEAK_UPDATE_URL = "https://api.thingspeak.com/update.json";

/* ==== MAP ==== */
let map = L.map('map').setView([53.35, -6.26], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap'
}).addTo(map);
let marker;

/* ==== GPS writer (80 s slotting) ==== */
const SLOT_MS = 80000;                 // match ESP32 period
let gpsWatchId = null;
let lastLat = null, lastLon = null;
let slotTimer = null;
let lastSlotSent = -1;

function setStatus(msg, cls = 'muted'){
  const el = document.getElementById('status');
  el.className = cls; el.textContent = msg;
}
const currentSlot = () => Math.floor(Date.now() / SLOT_MS);

async function postToThingSpeak(lat, lon){
  try {
    const body = new URLSearchParams({
      api_key: THINGSPEAK_WRITE_KEY,
      field7: lat,
      field8: lon
    });
    const r = await fetch(THINGSPEAK_UPDATE_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/x-www-form-urlencoded'},
      body: body.toString()
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const entryId = await r.json();   // ThingSpeak returns entry id or 0
    if (+entryId === 0) {
      setStatus('TS rejected GPS (rate/key?)', 'err');
      return false;
    }
    setStatus(`GPS uploaded: ${lat.toFixed(6)}, ${lon.toFixed(6)} (entry ${entryId})`, 'ok');
    return true;
  } catch(e){
    setStatus(`Upload error: ${e.message}`, 'err');
    return false;
  }
}

async function trySlotUpload(){
  if (lastLat == null || lastLon == null) return;
  const slot = currentSlot();
  if (slot === lastSlotSent) return;   // already sent this slot
  const ok = await postToThingSpeak(lastLat, lastLon);
  if (ok) lastSlotSent = slot;
}

document.getElementById('startBtn').addEventListener('click', () => {
  if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
  if (gpsWatchId) { setStatus('Already running', 'warn'); return; }

  setStatus('Starting GPS…');
  gpsWatchId = navigator.geolocation.watchPosition(pos => {
    lastLat = pos.coords.latitude;
    lastLon = pos.coords.longitude;

    if (marker) marker.setLatLng([lastLat, lastLon]);
    else marker = L.marker([lastLat, lastLon]).addTo(map);
    map.setView([lastLat, lastLon], Math.max(map.getZoom(), 15));

    // On first fix, attempt an immediate slot upload
    trySlotUpload();

    // Start 1 Hz slot checker (uploads exactly once per 80 s slot)
    if (!slotTimer) slotTimer = setInterval(trySlotUpload, 1000);
  }, err => {
    setStatus(`GPS error: ${err.message}`, 'err');
  }, { enableHighAccuracy:true, timeout:15000, maximumAge:0 });
});

document.getElementById('stopBtn').addEventListener('click', () => {
  if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
  if (slotTimer) { clearInterval(slotTimer); slotTimer = null; }
  setStatus('Stopped', 'muted');
});

/* ==== Fetch + merge viewer (same channel) ==== */
const tbl = document.getElementById('tbl');
const mergeStatus = document.getElementById('mergeStatus');
const dlBtn = document.getElementById('dlBtn');
let lastMerged = [];

function setMergeStatus(msg, cls='muted'){ mergeStatus.className = cls; mergeStatus.textContent = msg; }

async function readChannelFeeds(channelId, readKey, results) {
  const base = `https://api.thingspeak.com/channels/${channelId}/feeds.json`;
  const u = new URL(base);
  if (readKey) u.searchParams.set('api_key', readKey);
  u.searchParams.set('results', results);
  const r = await fetch(u.toString(), {cache:'no-store'});
  if (!r.ok) throw new Error(`TS read HTTP ${r.status}`);
  const j = await r.json();
  return j.feeds.map(f => ({
    created_at: f.created_at,
    ts: new Date(f.created_at).getTime(),
    pm1:   parseFloat(f.field1) || 0,
    pm25:  parseFloat(f.field2) || 0,
    pm10:  parseFloat(f.field3) || 0,
    co2:   parseFloat(f.field4) || 0,
    temp:  parseFloat(f.field5) || 0,
    hum:   parseFloat(f.field6) || 0,
    lat:   f.field7 !== undefined ? parseFloat(f.field7) : NaN,
    lon:   f.field8 !== undefined ? parseFloat(f.field8) : NaN
  }));
}

function mergeSameChannel(rows, windowSec){
  const W = windowSec * 1000;
  const sensors = rows.filter(r => (r.pm1||r.pm25||r.pm10||r.co2||r.temp||r.hum));
  const gps = rows.filter(r => Number.isFinite(r.lat) && Number.isFinite(r.lon));

  const out = [];
  for (const s of sensors) {
    let best = null, bestDt = Infinity;
    for (const g of gps) {
      const dt = Math.abs(s.ts - g.ts);
      if (dt < bestDt && dt <= W) { best = g; bestDt = dt; }
    }
    out.push({
      created_at: s.created_at,
      pm1: s.pm1, pm25: s.pm25, pm10: s.pm10,
      co2: s.co2, temp: s.temp, hum: s.hum,
      lat: best ? best.lat : '',
      lon: best ? best.lon : '',
      dt_s: best ? Math.round(bestDt/1000) : ''
    });
  }
  return out;
}

function renderTable(rows){
  if (!rows.length) { tbl.innerHTML = '<tr><td>No merged rows</td></tr>'; return; }
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  tbl.innerHTML =
    '<thead><tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr></thead>' +
    '<tbody>' + rows.map(r => '<tr>' +
      cols.map(c => `<td>${(r[c] ?? '')}</td>`).join('') +
    '</tr>').join('') + '</tbody>';

  const deltas = rows.map(r=>r.dt_s).filter(v=>typeof v==='number');
  if (deltas.length){
    const sum = deltas.reduce((a,b)=>a+b,0);
    const avg = Math.round(sum/deltas.length);
    const min = Math.min(...deltas);
    const max = Math.max(...deltas);
    setMergeStatus(`Done (${rows.length}). Δt [min=${min}s, avg=${avg}s, max=${max}s]`, 'ok');
  } else {
    setMergeStatus(`Done (${rows.length}). No GPS matches in window.`, 'warn');
  }
}

function toCSV(rows){
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  const lines = [cols.join(',')].concat(
    rows.map(r => cols.map(c => String(r[c] ?? '')).join(','))
  );
  return lines.join('\n');
}

document.getElementById('fetchBtn').addEventListener('click', async () => {
  const chId = document.getElementById('chId').value.trim();
  const readKey = document.getElementById('readKey').value.trim();
  const results = Math.max(10, parseInt(document.getElementById('results').value || '120', 10));
  const windowSec = Math.max(10, parseInt(document.getElementById('window').value || '90', 10));

  try {
    setMergeStatus('Fetching…');
    const rows = await readChannelFeeds(chId, readKey, results);
    setMergeStatus('Merging…');
    const merged = mergeSameChannel(rows, windowSec);
    lastMerged = merged;
    renderTable(merged);
    dlBtn.disabled = merged.length === 0;
  } catch (e) {
    setMergeStatus(`Error: ${e.message}`, 'err');
  }
});

document.getElementById('dlBtn').addEventListener('click', () => {
  if (!lastMerged.length) return;
  const blob = new Blob([toCSV(lastMerged)], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'merged_thingspeak.csv';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
</script>

</body>
</html>
