<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Odd-slot GPS → ThingSpeak + Merged Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root { --blue:#2563eb; --bg:#f6f7fb; --text:#111827; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:1rem;background:var(--bg);color:var(--text)}
    h1{margin:.2rem 0 .6rem}
    #map{height:380px;border-radius:10px;margin:10px 0;background:#e9eef5}
    .row{display:flex;flex-wrap:wrap;gap:1rem}
    .col{flex:1 1 360px;background:#fff;border-radius:12px;box-shadow:0 8px 18px rgba(0,0,0,.08);padding:1rem}
    .btn{padding:.6rem 1rem;border:0;border-radius:8px;cursor:pointer;font-weight:600}
    .primary{background:#2563eb;color:#fff}
    .ghost{background:#e5e7eb}
    .ok{color:#16a34a}.warn{color:#f59e0b}.err{color:#ef4444}.muted{color:#6b7280}
    table{width:100%;border-collapse:collapse;font-size:.95rem}
    th,td{border:1px solid #e5e7eb;padding:.45rem .5rem}
    th{background:#f3f4f6;text-align:left;position:sticky;top:0}
    .controls label{display:block;font-size:.9rem;margin:.4rem 0 .2rem}
    .controls input{width:100%;padding:.45rem .5rem;border:1px solid #d1d5db;border-radius:8px}
    .kv{font-size:.95rem;line-height:1.6;margin:.2rem 0}
    .kv b{display:inline-block;min-width:9ch}
  </style>
</head>
<body>

<h1>Odd-slot GPS → ThingSpeak + Merged Table</h1>
<p class="kv">Status: <span id="status" class="muted">Idle</span></p>

<div class="row">
  <!-- LEFT: GPS uploader + map -->
  <div class="col">
    <div style="display:flex;gap:.5rem;flex-wrap:wrap">
      <button class="btn primary" id="startBtn">Start GPS Upload</button>
      <button class="btn ghost" id="stopBtn">Stop</button>
    </div>

    <div id="map" aria-label="Live phone GPS"></div>

    <div class="kv"><b>Lat/Lon:</b> <span id="lat">—</span>, <span id="lon">—</span></div>
    <div class="kv"><b>Slot:</b> <span id="slot">—</span> (<span id="slotParity">—</span>)</div>
    <div class="kv"><b>Next check:</b> <span id="countdown">—</span></div>

    <div class="controls" style="margin-top:.8rem">
      <label>Write API Key</label>
      <input id="writeKey" value="9YXHS30JF6Z9YHXI"/>
      <label>Slot Length (seconds, keep 80)</label>
      <input id="slotLen" type="number" value="80"/>
    </div>

    <p class="muted" style="margin:.4rem 0 0">This page writes GPS to <b>field7/field8</b> on <b>odd</b> slots only.</p>
  </div>

  <!-- RIGHT: Merge viewer -->
  <div class="col">
    <h3 style="margin:.2rem 0 .6rem">Fetch & Merge (same channel)</h3>
    <div class="controls">
      <label>Channel ID</label>
      <input id="chId" value="2960675"/>
      <label>Read API Key (leave blank if public)</label>
      <input id="readKey" value=""/>
      <label>How many latest rows</label>
      <input id="results" type="number" value="200"/>
      <label>Merge window (seconds)</label>
      <input id="window" type="number" value="90"/>
    </div>
    <p style="margin:.6rem 0;display:flex;gap:.5rem;flex-wrap:wrap">
      <button class="btn primary" id="fetchBtn">Fetch & Merge</button>
      <button class="btn ghost" id="dlBtn" disabled>Download CSV</button>
    </p>
    <div id="mergeStatus" class="muted">Waiting…</div>
    <div style="max-height:340px;overflow:auto;margin-top:.5rem">
      <table id="tbl"></table>
    </div>
  </div>
</div>

<script>
/* ===================== MAP ===================== */
let map = L.map('map').setView([53.35, -6.26], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap'
}).addTo(map);
let marker;

/* ===================== UI helpers ===================== */
const $ = s => document.querySelector(s);
function setText(sel, v){ const el=$(sel); if (el) el.textContent=v; }
function setStatus(msg, cls='muted'){ const el=$("#status"); el.className=cls; el.textContent=msg; }

/* ===================== GPS uploader (ODD 80s slots) ===================== */
let gpsWatchId = null;
let lastLat=null, lastLon=null;
let slotTimer=null;
let lastSlotSent = -1;

function currentSlot(slotSec){
  return Math.floor((Date.now()/1000) / slotSec);
}
function updateSlotUI(slotSec){
  const s = currentSlot(slotSec);
  setText('#slot', s);
  setText('#slotParity', (s%2) ? 'odd (GPS)' : 'even (ESP32)');
}
function startCountdown(slotSec){
  // show seconds until next whole second tick (just a heartbeat)
  let n = 1;
  setText('#countdown', `${n}s`);
  return setInterval(()=>{ n = (n%slotSec)+1; setText('#countdown', `${n}s`); }, 1000);
}
let countdownTimer = null;

async function postToThingSpeak(lat, lon, writeKey){
  try{
    const body = new URLSearchParams({
      api_key: writeKey,
      field7: lat,
      field8: lon
    });
    const r = await fetch('https://api.thingspeak.com/update.json', {
      method:'POST',
      headers:{'Content-Type':'application/x-www-form-urlencoded'},
      body: body.toString()
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const entryId = await r.json();
    if (+entryId === 0){
      setStatus('TS rejected GPS (rate/key?)', 'err');
      return false;
    }
    setStatus(`GPS uploaded (entry ${entryId})`, 'ok');
    return true;
  }catch(e){
    setStatus(`Upload error: ${e.message}`, 'err');
    return false;
  }
}

async function tryOddSlotUpload(slotSec, writeKey){
  if (lastLat==null || lastLon==null) return;
  const s = currentSlot(slotSec);
  updateSlotUI(slotSec);

  if ((s % 2) !== 1) return;       // only odd slots for GPS
  if (s === lastSlotSent) return;  // already sent this slot

  // small jitter to avoid exact boundaries
  await new Promise(res=>setTimeout(res, 200 + (Math.random()*800|0)));

  const ok = await postToThingSpeak(lastLat, lastLon, writeKey);
  if (ok) lastSlotSent = s;
}

$("#startBtn").addEventListener('click', () => {
  const slotSec = Math.max(30, parseInt($("#slotLen").value||'80',10));
  const writeKey = $("#writeKey").value.trim();
  if (!writeKey){ alert('Enter your Write API Key'); return; }
  if (!navigator.geolocation){ alert('Geolocation not supported'); return; }
  if (gpsWatchId){ setStatus('Already running', 'warn'); return; }

  setStatus('Starting GPS…');
  gpsWatchId = navigator.geolocation.watchPosition(pos=>{
    lastLat = pos.coords.latitude;
    lastLon = pos.coords.longitude;

    setText('#lat', lastLat.toFixed(6));
    setText('#lon', lastLon.toFixed(6));

    if (marker) marker.setLatLng([lastLat, lastLon]);
    else marker = L.marker([lastLat, lastLon]).addTo(map);
    map.setView([lastLat, lastLon], Math.max(map.getZoom(), 15));

    // attempt upload on first fix if we're in an odd slot
    tryOddSlotUpload(slotSec, writeKey);

    // start 1 Hz slot checker
    if (!slotTimer){
      slotTimer = setInterval(()=>tryOddSlotUpload(slotSec, writeKey), 1000);
    }
    if (!countdownTimer){
      countdownTimer = startCountdown(slotSec);
    }
    updateSlotUI(slotSec);
  }, err=>{
    setStatus(`GPS error: ${err.message}`, 'err');
  }, { enableHighAccuracy:true, timeout:15000, maximumAge:0 });
});

$("#stopBtn").addEventListener('click', () => {
  if (gpsWatchId){ navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId=null; }
  if (slotTimer){ clearInterval(slotTimer); slotTimer=null; }
  if (countdownTimer){ clearInterval(countdownTimer); countdownTimer=null; }
  setStatus('Stopped', 'muted');
});

/* ===================== Fetch + Merge (only rows WITH GPS) ===================== */
const tbl = $("#tbl");
const mergeStatus = $("#mergeStatus");
const dlBtn = $("#dlBtn");
let lastMerged = [];

function setMergeStatus(msg, cls='muted'){ mergeStatus.className = cls; mergeStatus.textContent = msg; }

async function readChannelFeeds(channelId, readKey, results) {
  const base = `https://api.thingspeak.com/channels/${channelId}/feeds.json`;
  const u = new URL(base);
  if (readKey) u.searchParams.set('api_key', readKey);
  u.searchParams.set('results', results);
  const r = await fetch(u.toString(), {cache:'no-store'});
  if (!r.ok) throw new Error(`TS read HTTP ${r.status}`);
  const j = await r.json();
  return j.feeds.map(f => ({
    created_at: f.created_at,
    ts: new Date(f.created_at).getTime(),
    pm1:   f.field1 !== null ? parseFloat(f.field1) : NaN,
    pm25:  f.field2 !== null ? parseFloat(f.field2) : NaN,
    pm10:  f.field3 !== null ? parseFloat(f.field3) : NaN,
    co2:   f.field4 !== null ? parseFloat(f.field4) : NaN,
    temp:  f.field5 !== null ? parseFloat(f.field5) : NaN,
    hum:   f.field6 !== null ? parseFloat(f.field6) : NaN,
    lat:   f.field7 !== null ? parseFloat(f.field7) : NaN,
    lon:   f.field8 !== null ? parseFloat(f.field8) : NaN
  }));
}

function mergeSameChannel(rows, windowSec){
  const W = windowSec * 1000;

  // split streams
  const sensors = rows.filter(r =>
    [r.pm1,r.pm25,r.pm10,r.co2,r.temp,r.hum].some(v => Number.isFinite(v))
  );
  const gps = rows.filter(r => Number.isFinite(r.lat) && Number.isFinite(r.lon));

  const out = [];
  for (const s of sensors) {
    // nearest GPS within window
    let best = null, bestDt = Infinity;
    for (const g of gps) {
      const dt = Math.abs(s.ts - g.ts);
      if (dt < bestDt && dt <= W) { best = g; bestDt = dt; }
    }
    // IMPORTANT: only include if we found GPS
    if (best) {
      out.push({
        created_at: s.created_at,
        pm1: fixNum(s.pm1), pm25: fixNum(s.pm25), pm10: fixNum(s.pm10),
        co2: fixNum(s.co2), temp: fixNum(s.temp), hum: fixNum(s.hum),
        lat: best.lat, lon: best.lon,
        dt_s: Math.round(bestDt/1000)
      });
    }
  }
  return out;
}
function fixNum(v){ return Number.isFinite(v) ? +(+v).toFixed(5) : ''; }

function renderTable(rows){
  if (!rows.length) { tbl.innerHTML = '<tr><td>No merged rows with GPS in window.</td></tr>'; return; }
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  tbl.innerHTML =
    '<thead><tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr></thead>' +
    '<tbody>' + rows.map(r => '<tr>' +
      cols.map(c => `<td>${(r[c] ?? '')}</td>`).join('') +
    '</tr>').join('') + '</tbody>';

  const deltas = rows.map(r=>r.dt_s).filter(v=>typeof v==='number');
  if (deltas.length){
    const sum = deltas.reduce((a,b)=>a+b,0);
    const avg = Math.round(sum/deltas.length);
    const min = Math.min(...deltas);
    const max = Math.max(...deltas);
    setMergeStatus(`Done (${rows.length}). Δt [min=${min}s, avg=${avg}s, max=${max}s]`, 'ok');
  } else {
    setMergeStatus(`Done (${rows.length}).`, 'ok');
  }
}

function toCSV(rows){
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  const lines = [cols.join(',')].concat(
    rows.map(r => cols.map(c => String(r[c] ?? '')).join(','))
  );
  return lines.join('\n');
}

$("#fetchBtn").addEventListener('click', async () => {
  const chId = $("#chId").value.trim();
  const readKey = $("#readKey").value.trim();
  const results = Math.max(10, parseInt($("#results").value || '200', 10));
  const windowSec = Math.max(10, parseInt($("#window").value || '90', 10));

  try {
    setMergeStatus('Fetching…');
    const rows = await readChannelFeeds(chId, readKey, results);
    setMergeStatus('Merging…');
    const merged = mergeSameChannel(rows, windowSec);
    lastMerged = merged;
    renderTable(merged);
    $("#dlBtn").disabled = merged.length === 0;
  } catch (e) {
    setMergeStatus(`Error: ${e.message}`, 'err');
  }
});

$("#dlBtn").addEventListener('click', () => {
  if (!lastMerged.length) return;
  const blob = new Blob([toCSV(lastMerged)], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'merged_thingspeak.csv';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
</script>

</body>
</html>
