<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ESP + GPS → ThingSpeak</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    #map { height: 400px; border-radius: 8px; margin-top: 10px; }
    .btn { padding: 0.6rem 1rem; margin: 0.3rem; border: none; border-radius: 6px; cursor: pointer; }
    .primary { background: #2563eb; color: white; }
    .ghost { background: #ccc; }
  </style>
</head>
<body>

<h1>ESP32 + GPS → ThingSpeak</h1>
<p>Status: <span id="status">Idle</span></p>
<button class="btn primary" id="startBtn">Start Upload</button>
<button class="btn ghost" id="stopBtn">Stop Upload</button>

<div id="map"></div>
  <script>
  const ESP_BASE = 'http://10.229.188.187';            // your ESP32 IP
const THINGSPEAK_WRITE_KEY = '9YXHS30JF6Z9YHXI';
const THINGSPEAK_URL = 'https://api.thingspeak.com/update.json';

function getGPS() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('No geolocation'));
    navigator.geolocation.getCurrentPosition(
      pos => resolve({
        lat: +pos.coords.latitude,
        lon: +pos.coords.longitude
      }),
      err => reject(err),
      { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
    );
  });
}

async function getSensors() {
  const r = await fetch(`${ESP_BASE}/sensors`);
  if (!r.ok) throw new Error(`ESP /sensors HTTP ${r.status}`);
  const j = await r.json();
  // coerce to numbers; may be undefined on first seconds after boot
  return {
    pm1:  Number.isFinite(+j.pm1) ? +j.pm1 : null,
    pm25: Number.isFinite(+j.pm25) ? +j.pm25 : null,
    pm10: Number.isFinite(+j.pm10) ? +j.pm10 : null,
    co2:  Number.isFinite(+j.co2) ? +j.co2 : null,
    temp: Number.isFinite(+j.temperature) ? +j.temperature : null,
    hum:  Number.isFinite(+j.humidity) ? +j.humidity : null,
  };
}

async function sendCombined() {
  try {
    const [gps, s] = await Promise.all([getGPS(), getSensors()]);
    // if sensors not ready yet, skip this tick to avoid zeros
    if ([s.pm1,s.pm25,s.pm10,s.co2,s.temp,s.hum].some(v => v === null)) {
      console.log('Skip: sensors not ready yet');
      return;
    }

    const params = new URLSearchParams({
      api_key: THINGSPEAK_WRITE_KEY,
      field1: s.pm1,
      field2: s.pm25,
      field3: s.pm10,
      field4: s.co2,
      field5: s.temp,
      field6: s.hum,
      field7: gps.lat,
      field8: gps.lon,
      status: 'browser-combined'
    });

    const r = await fetch(THINGSPEAK_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/x-www-form-urlencoded'},
      body: params.toString()
    });
    if (!r.ok) throw new Error(`ThingSpeak HTTP ${r.status}`);
    console.log('ThingSpeak OK');
  } catch (e) {
    console.warn('Combined upload failed:', e.message);
  }
}

// run once immediately, then every 80 s
sendCombined();
setInterval(sendCombined, 80000);

</script>
<!--
<script>
const THINGSPEAK_API_KEY = "9YXHS30JF6Z9YHXI"; // ThingSpeak Write API Key
const THINGSPEAK_UPDATE_URL = "https://api.thingspeak.com/update";
const ESP32_IP = "10.229.188.187"; // ESP32 local IP address

let map = L.map('map').setView([0, 0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);
let marker;

let gpsWatchId = null;
let sendTimer = null;
let lastLat = null;
let lastLon = null;

async function fetchEsp32Data() {
  try {
    let res = await fetch(`http://${ESP32_IP}/sensors`);
    return await res.json();
  } catch (err) {
    console.error("ESP32 fetch error", err);
    return {};
  }
}

async function sendToThingSpeak() {
  if (lastLat === null || lastLon === null) {
    document.getElementById("status").textContent = "No GPS yet...";
    return;
  }

  let sensors = await fetchEsp32Data();

  let url = `${THINGSPEAK_UPDATE_URL}?api_key=${THINGSPEAK_API_KEY}` +
    `&field1=${sensors.pm1 || 0}` +
    `&field2=${sensors.pm25 || 0}` +
    `&field3=${sensors.pm10 || 0}` +
    `&field4=${sensors.co2 || 0}` +
    `&field5=${sensors.temperature || 0}` +
    `&field6=${sensors.humidity || 0}` +
    `&field7=${lastLat}` +
    `&field8=${lastLon}`;

  try {
    let res = await fetch(url);
    let text = await res.text();
    if (text.trim() === "0") {
      document.getElementById("status").textContent = "ThingSpeak rejected update";
    } else {
      document.getElementById("status").textContent = `Uploaded row #${text.trim()} (${lastLat.toFixed(6)}, ${lastLon.toFixed(6)})`;
    }
  } catch (err) {
    console.error(err);
    document.getElementById("status").textContent = "Upload error";
  }
}

document.getElementById("startBtn").addEventListener("click", () => {
  if (!navigator.geolocation) {
    alert("Geolocation not supported");
    return;
  }

  document.getElementById("status").textContent = "Starting GPS...";

  gpsWatchId = navigator.geolocation.watchPosition(pos => {
    lastLat = pos.coords.latitude;
    lastLon = pos.coords.longitude;

    if (marker) marker.setLatLng([lastLat, lastLon]);
    else marker = L.marker([lastLat, lastLon]).addTo(map);
    map.setView([lastLat, lastLon], 16);
  }, err => {
    console.error(err);
    document.getElementById("status").textContent = "GPS error";
  }, { enableHighAccuracy: true });

  sendTimer = setInterval(sendToThingSpeak, 60000); // every 15 sec
});

document.getElementById("stopBtn").addEventListener("click", () => {
  if (gpsWatchId) {
    navigator.geolocation.clearWatch(gpsWatchId);
    gpsWatchId = null;
  }
  if (sendTimer) {
    clearInterval(sendTimer);
    sendTimer = null;
  }
  document.getElementById("status").textContent = "Stopped";
});
</script>
  -->

</body>
</html>
