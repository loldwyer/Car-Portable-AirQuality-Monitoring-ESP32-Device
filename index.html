<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>30s GPS → ThingSpeak + Merge Viewer (Aligned + Interpolated)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:1rem;background:#f6f7fb;color:#111}
    h1{margin:.2rem 0 1rem}
    #map{height:380px;border-radius:10px;margin:10px 0;background:#e9eef5}
    .row{display:flex;flex-wrap:wrap;gap:1rem}
    .col{flex:1 1 340px;background:#fff;border-radius:12px;box-shadow:0 8px 18px rgba(0,0,0,.08);padding:1rem}
    .btn{padding:.6rem 1rem;border:0;border-radius:8px;cursor:pointer;font-weight:600}
    .primary{background:#2563eb;color:#fff}.ghost{background:#e5e7eb}
    .ok{color:#16a34a}.warn{color:#f59e0b}.err{color:#ef4444}.muted{color:#6b7280}
    table{width:100%;border-collapse:collapse;font-size:.95rem}
    th,td{border:1px solid #e5e7eb;padding:.45rem .5rem}
    th{background:#f3f4f6;text-align:left}
    .controls label{display:block;font-size:.9rem;margin:.4rem 0 .2rem}
    .controls input{width:100%;padding:.45rem .5rem;border:1px solid #d1d5db;border-radius:8px}
    small{color:#6b7280}
  </style>
</head>
<body>

<h1>GPS → ThingSpeak (phone 4G) + Merged Table</h1>
<p>Status: <span id="status" class="muted">Idle</span></p>

<div class="row">
  <!-- LEFT: GPS uploader + map -->
  <div class="col">
    <button class="btn primary" id="startBtn">Start GPS Upload</button>
    <button class="btn ghost" id="stopBtn">Stop</button>
    <div style="margin-top:.5rem">
      <small>Uploads every 30 s exactly on wall-clock boundaries and includes <code>created_at</code> (UTC).</small>
    </div>
    <div id="map"></div>
    <p class="muted" style="margin:.2rem 0 0">
      Writes: field7 = Latitude, field8 = Longitude
    </p>
  </div>

  <!-- RIGHT: Merge viewer -->
  <div class="col">
    <h3 style="margin:.2rem 0 .6rem">Fetch & Merge from ThingSpeak (same channel)</h3>
    <div class="controls">
      <label>Channel ID</label>
      <input id="chId" value="2960675" />
      <label>Read API Key (leave blank if public)</label>
      <input id="readKey" value="" />
      <label>How many latest rows</label>
      <input id="results" type="number" value="200" />
      <label>Merge window (seconds) <small>(max |Δt| allowed)</small></label>
      <input id="window" type="number" value="90" />
    </div>
    <p style="margin:.6rem 0">
      <button class="btn primary" id="fetchBtn">Fetch & Merge</button>
      <button class="btn ghost" id="dlBtn" disabled>Download CSV</button>
    </p>
    <div id="mergeStatus" class="muted">Waiting…</div>
    <div style="max-height:340px;overflow:auto;margin-top:.5rem">
      <table id="tbl"></table>
    </div>
  </div>
</div>

<script>
/* ==== CONFIG (GPS writer) ==== */
const THINGSPEAK_WRITE_KEY = "9YXHS30JF6Z9YHXI";
const THINGSPEAK_UPDATE_URL = "https://api.thingspeak.com/update.json";

/* ==== MAP ==== */
let map = L.map('map').setView([53.35, -6.26], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap'
}).addTo(map);
let marker;

/* ==== GPS writer (aligned 30 s) ==== */
const PERIOD_MS = 30000;
let gpsWatchId = null;
let lastFix = null; // {lat, lon, t: ms}
let slotTimer = null;

function setStatus(msg, cls = 'muted'){
  const el = document.getElementById('status'); el.className = cls; el.textContent = msg;
}
function nextBoundaryDelay(ms = Date.now()) { return PERIOD_MS - (ms % PERIOD_MS); }
function isoFloorToBoundary(ms = Date.now()){
  const t = ms - (ms % PERIOD_MS);
  return new Date(t).toISOString(); // UTC ISO8601
}

async function postToThingSpeak(lat, lon, createdAtIso){
  try {
    const body = new URLSearchParams({
      api_key: THINGSPEAK_WRITE_KEY,
      field7: lat,
      field8: lon,
      created_at: createdAtIso   // <-- our timestamp, not TS server time
    });
    const r = await fetch(THINGSPEAK_UPDATE_URL, {
      method: 'POST',
      headers: {'Content-Type':'application/x-www-form-urlencoded'},
      body: body.toString()
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const entryId = await r.json();   // entry id or 0
    if (+entryId === 0) { setStatus('TS rejected GPS (rate/key?)', 'err'); return false; }
    setStatus(`GPS uploaded @ ${createdAtIso}: ${lat.toFixed(6)}, ${lon.toFixed(6)} (entry ${entryId})`, 'ok');
    return true;
  } catch(e){
    setStatus(`Upload error: ${e.message}`, 'err');
    return false;
  }
}

function startAlignedUploader(){
  // kick at next boundary, then every 30 s
  setTimeout(async () => {
    if (lastFix) await postToThingSpeak(lastFix.lat, lastFix.lon, isoFloorToBoundary(lastFix.t));
    slotTimer = setInterval(async () => {
      const now = Date.now();
      if (lastFix) await postToThingSpeak(lastFix.lat, lastFix.lon, isoFloorToBoundary(now));
    }, PERIOD_MS);
  }, nextBoundaryDelay());
}

document.getElementById('startBtn').addEventListener('click', () => {
  if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
  if (gpsWatchId) { setStatus('Already running', 'warn'); return; }

  setStatus('Starting GPS…');
  gpsWatchId = navigator.geolocation.watchPosition(pos => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    lastFix = { lat, lon, t: Date.now() };

    if (marker) marker.setLatLng([lat, lon]);
    else marker = L.marker([lat, lon]).addTo(map);
    map.setView([lat, lon], Math.max(map.getZoom(), 15));
  }, err => {
    setStatus(`GPS error: ${err.message}`, 'err');
  }, { enableHighAccuracy:true, timeout:15000, maximumAge:0 });

  startAlignedUploader();
});

document.getElementById('stopBtn').addEventListener('click', () => {
  if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
  if (slotTimer) { clearInterval(slotTimer); slotTimer = null; }
  setStatus('Stopped', 'muted');
});

/* ==== Fetch + merge viewer (same channel) ==== */
const tbl = document.getElementById('tbl');
const mergeStatus = document.getElementById('mergeStatus');
const dlBtn = document.getElementById('dlBtn');
let lastMerged = [];

function setMergeStatus(msg, cls='muted'){ mergeStatus.className = cls; mergeStatus.textContent = msg; }

async function readChannelFeeds(channelId, readKey, results) {
  const base = `https://api.thingspeak.com/channels/${channelId}/feeds.json`;
  const u = new URL(base);
  if (readKey) u.searchParams.set('api_key', readKey);
  u.searchParams.set('results', results);
  const r = await fetch(u.toString(), {cache:'no-store'});
  if (!r.ok) throw new Error(`TS read HTTP ${r.status}`);
  const j = await r.json();
  return j.feeds.map(f => ({
    created_at: f.created_at,
    ts: new Date(f.created_at).getTime(),
    pm1:   parseFloat(f.field1),
    pm25:  parseFloat(f.field2),
    pm10:  parseFloat(f.field3),
    co2:   parseFloat(f.field4),
    temp:  parseFloat(f.field5),
    hum:   parseFloat(f.field6),
    lat:   (f.field7 !== undefined && f.field7 !== null) ? parseFloat(f.field7) : NaN,
    lon:   (f.field8 !== undefined && f.field8 !== null) ? parseFloat(f.field8) : NaN
  }));
}

/* Interpolate GPS between surrounding GPS points for each sensor timestamp. */
function mergeInterpolated(rows, windowSec){
  const W = windowSec * 1000;
  const sensors = rows.filter(r => [r.pm1,r.pm25,r.pm10,r.co2,r.temp,r.hum].some(v => Number.isFinite(v)));
  const gps = rows.filter(r => Number.isFinite(r.lat) && Number.isFinite(r.lon))
                  .sort((a,b)=>a.ts-b.ts);

  function interpLatLon(t){
    // find bracketing GPS points
    let i = 0, j = gps.length - 1;
    if (gps.length === 0) return null;
    if (t <= gps[0].ts)  { if (Math.abs(t-gps[0].ts) > W) return null; return {lat:gps[0].lat, lon:gps[0].lon, dt:Math.abs(t-gps[0].ts)}; }
    if (t >= gps[j].ts)  { if (Math.abs(t-gps[j].ts) > W) return null; return {lat:gps[j].lat, lon:gps[j].lon, dt:Math.abs(t-gps[j].ts)}; }
    // binary search
    let lo=0, hi=gps.length-1;
    while (hi-lo>1){ const mid=(lo+hi)>>1; (gps[mid].ts<t? lo=mid : hi=mid); }
    const g0=gps[lo], g1=gps[hi];
    const span = g1.ts - g0.ts;
    if (span<=0) return null;
    const alpha = (t - g0.ts) / span;
    const lat = g0.lat + alpha*(g1.lat - g0.lat);
    const lon = g0.lon + alpha*(g1.lon - g0.lon);
    const dt = Math.min(Math.abs(t-g0.ts), Math.abs(t-g1.ts));
    if (dt > W) return null;
    return {lat, lon, dt};
  }

  const out = [];
  for (const s of sensors) {
    const g = interpLatLon(s.ts);
    out.push({
      created_at: s.created_at,
      pm1: s.pm1 ?? '', pm25: s.pm25 ?? '', pm10: s.pm10 ?? '',
      co2: s.co2 ?? '', temp: s.temp ?? '', hum: s.hum ?? '',
      lat: g ? g.lat.toFixed(6) : '',
      lon: g ? g.lon.toFixed(6) : '',
      dt_s: g ? Math.round(g.dt/1000) : ''
    });
  }
  return out;
}

function renderTable(rows){
  if (!rows.length) { tbl.innerHTML = '<tr><td>No merged rows</td></tr>'; return; }
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  tbl.innerHTML =
    '<thead><tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr></thead>' +
    '<tbody>' + rows.map(r => '<tr>' +
      cols.map(c => `<td>${(r[c] ?? '')}</td>`).join('') +
    '</tr>').join('') + '</tbody>';

  const deltas = rows.map(r=>r.dt_s).filter(v=>typeof v==='number');
  if (deltas.length){
    const sum = deltas.reduce((a,b)=>a+b,0);
    const avg = Math.round(sum/deltas.length);
    const min = Math.min(...deltas);
    const max = Math.max(...deltas);
    setMergeStatus(`Done (${rows.length}). Δt [min=${min}s, avg=${avg}s, max=${max}s]`, 'ok');
  } else {
    setMergeStatus(`Done (${rows.length}). No GPS matches in window.`, 'warn');
  }
}

function toCSV(rows){
  const cols = ['created_at','pm1','pm25','pm10','co2','temp','hum','lat','lon','dt_s'];
  const lines = [cols.join(',')].concat(
    rows.map(r => cols.map(c => String(r[c] ?? '')).join(','))
  );
  return lines.join('\n');
}

document.getElementById('fetchBtn').addEventListener('click', async () => {
  const chId = document.getElementById('chId').value.trim();
  const readKey = document.getElementById('readKey').value.trim();
  const results = Math.max(10, parseInt(document.getElementById('results').value || '200', 10));
  const windowSec = Math.max(5, parseInt(document.getElementById('window').value || '90', 10));

  try {
    setMergeStatus('Fetching…');
    const rows = await readChannelFeeds(chId, readKey, results);
    setMergeStatus('Merging (interpolated)…');
    const merged = mergeInterpolated(rows, windowSec);
    lastMerged = merged;
    renderTable(merged);
    dlBtn.disabled = merged.length === 0;
  } catch (e) {
    setMergeStatus(`Error: ${e.message}`, 'err');
  }
});

document.getElementById('dlBtn').addEventListener('click', () => {
  if (!lastMerged.length) return;
  const blob = new Blob([toCSV(lastMerged)], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'merged_thingspeak.csv';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
</script>

</body>
</html>
